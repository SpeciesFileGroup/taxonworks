# lib/autoselect/levels/smart.rb
#
# Default level that delegates to the existing Queries::<Model>::Autocomplete class.
# Wraps all existing autocomplete logic and makes it available as a level.
# Generated by default for all model autoselects.
#
# Subclasses must override #query_class to specify the concrete Query class.
#
class Autoselect::Levels::Smart < Autoselect::Level

  # @return [Class] the Queries::<Model>::Autocomplete class to delegate to
  def query_class
    raise NotImplementedError, "#{self.class} must implement #query_class"
  end

  def key
    :smart
  end

  def label
    'Smart'
  end

  def description
    'Full-text and similarity-based search using all indexed fields'
  end

  # @param term [String]
  # @param operator [Symbol, nil] :recent, :recent_mine, or nil
  # @param project_id [Integer, nil]
  # @param user_id [Integer, nil]
  # @param kwargs [Hash] passed through to the query class
  # @return [Array] of ActiveRecord model instances
  def call(term:, operator: nil, project_id: nil, user_id: nil, **kwargs)
    case operator
    when :recent
      recent_records(project_id:)
    when :recent_mine
      recent_records_by_user(project_id:, user_id:)
    when :help
      [] # help is UI-only; return empty so UI renders the overlay
    else
      query_class.new(term, project_id:, **kwargs).autocomplete
    end
  end

  private

  def recent_records(project_id:)
    return [] if project_id.blank?
    model_class.where(project_id:).order(updated_at: :desc).limit(20).to_a
  end

  def recent_records_by_user(project_id:, user_id:)
    return [] if project_id.blank? || user_id.blank?
    model_class.where(project_id:, updated_by_id: user_id).order(updated_at: :desc).limit(20).to_a
  end

  # Derive the model class from the query_class namespace.
  # e.g. Queries::TaxonName::Autocomplete -> ::TaxonName
  def model_class
    ('::' + query_class.name.split('::')[1]).constantize
  end

end
