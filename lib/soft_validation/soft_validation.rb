module SoftValidation

  # A SoftValidation identifies an individual issue with the instance
  # it has been run against. It is generated by a soft_validation_method.
  #
  # @!attribute attribute
  #   @return [Symbol]
  #     the attribute (column name), or :base to which the soft validation is tied
  #
  # @!attribute message
  #   @return [String]
  #     Required.  A short message describing the soft validation
  #
  # @!attribute fix
  #   @return [Symbol]
  #     Optional. Identifies a method that fixes the soft validation in question.  I.e. the method
  #     when run should eliminate subsequent identical soft validation warnings from being generated.
  #     Fix methods should return true or false.
  #
  # @!attribute fix_trigger
  #   @return [Symbol]
  #     Optional when :fix is provided. Must be one of :automatic or :requested. Defaults to :automatic
  #
  # @!attribute success_message
  #   @return [String]
  #     Optional.  Requires a fix method.  A short message describing the message provided when the soft validation was successfully fixed.
  #
  # @!attribute failure_message
  #   @return [String]
  #     Optional.  Requires a fix method.  A short message describing the message provided when the soft validation was NOT successfully fixed.
  #
  # @!attribute fixed
  #   @return [Symbol]
  #     Stores a state with one of
  #     :fixed                  (fixes run and SoftValidation was fixed),
  #     :fix_error              (fixes run and SoftValidation fix failed),
  #     :fix_not_triggered      (fixes run, and SoftValidation was not triggered because of scope)
  #     :fix_not_yet_run        (there is a fix method available, but it hasn't been run)
  #     :no_fix_available       (no fix method was provided)
  class SoftValidation
    attr_accessor :attribute, :message, :fix, :fix_trigger, :success_message, :failure_message, :fixed, :resolution

    # @param [Hash] args
    def initialize(options = {})
      @fixed = :fix_not_yet_run

      options.each do |k,v|
        send("#{k}=", v)
      end
    end

    # @return [Boolean]
    def fixed?
      return true if fixed == :fixed
      false
    end

    # @return [String]
    def result_message
      case fixed
      when :fix_not_triggered
        'fix available, but not triggered'
      when :no_fix_available
        'fix not run, no automatic fix available'
      when :fix_not_yet_run
        'fix not yet run'
      when :fixed
        self.success_message.nil? ? "'#{message}' was fixed (no result message provided)" : self.success_message
      when :fix_error
        self.failure_message.nil? ? "'#{message}' was NOT fixed (no result message provided)" : self.failure_message
      end
    end
  end
end

