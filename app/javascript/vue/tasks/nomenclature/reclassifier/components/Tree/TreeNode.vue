<template>
  <li class="cursor-grab">
    <VBtn
      v-if="!taxon.leaf"
      circle
      small
      color="primary"
      :disabled="isLoading"
      @click="toggle"
    >
      <span v-if="taxon.isLoaded && taxon.isExpanded">-</span>
      <span v-else>+</span>
    </VBtn>

    <span
      :class="['list-reclassifer-taxon-item', isSelected && 'selected']"
      v-html="taxon.name"
      @click="() => addToSelected(taxon)"
    />

    <ul
      class="taxonomy-tree"
      v-if="store.isDragging && isMouseover"
    >
      <li
        v-for="item in store.selected[store.currentDragged.parent.id] || {}"
        :key="item.id"
        class="ghost-list"
      >
        <span
          class="list-reclassifer-taxon-item selected"
          v-html="item.name"
        />
      </li>
    </ul>

    <template v-if="(!taxon.isLoaded || taxon.isExpanded) && taxon.children">
      <VDraggable
        class="taxonomy-tree"
        ref="rootEl"
        item-key="id"
        :group="group"
        v-model="taxon.children"
        tag="ul"
        :sort="false"
        :data-parent-id="taxon.id"
        :data-tree="group.name"
        @add="handleAdd"
        @choose="handleChoose"
        @start="() => (store.isDragging = true)"
        @end="
          () => {
            store.isDragging = false
            onDragEndCleanup()
          }
        "
      >
        <template #item="{ element }">
          <TreeNode
            :taxon="element"
            :group="group"
            :data-parent-id="taxon.id"
            :data-taxon-id="element.id"
            :only-valid="onlyValid"
            :tree="tree"
            :target="target"
          />
        </template>
      </VDraggable>
    </template>
  </li>
</template>

<script setup>
import { computed, ref, toRaw, onMounted, onBeforeUnmount } from 'vue'
import { TaxonName } from '@/routes/endpoints'
import { findNodeById, removeNode } from '../../utils'
import TreeNode from './TreeNode.vue'
import VBtn from '@/components/ui/VBtn/index.vue'
import VDraggable from 'vuedraggable'
import useStore from '../../store/store.js'
import { usePressedKey } from '@/composables/usePressedKey'

const GHOST_SELECTOR = '.sortable-ghost'

const props = defineProps({
  taxon: {
    type: Object,
    required: true
  },

  group: {
    type: Object,
    required: true
  },

  onlyValid: {
    type: Boolean,
    default: false
  },

  tree: {
    type: Object,
    required: true
  },

  target: {
    type: Array,
    required: true
  }
})

const isLoading = ref(false)
const store = useStore()
const isMouseover = ref(false)
const { isKeyPressed } = usePressedKey()

const rootEl = ref(null)

let observer = null

function updateIsMouseoverFromGhost() {
  const ghost = document.querySelector(GHOST_SELECTOR)
  if (!ghost) {
    if (isMouseover.value) isMouseover.value = false
    return
  }

  const ghostList = ghost.closest('.taxonomy-tree')

  isMouseover.value = ghostList === rootEl.value.$el
}

function setupObserverForRoot(el) {
  if (!el) return

  observer = new MutationObserver(() => {
    updateIsMouseoverFromGhost()
  })

  observer.observe(document.body, { childList: true, subtree: true })
}

onMounted(() => setupObserverForRoot(rootEl.value.$el))
onBeforeUnmount(() => {
  observer?.disconnect()
})

function onDragEndCleanup() {
  isMouseover.value = false
}

function addToSelected(item) {
  if (isKeyPressed('Control')) {
    const selectedItems = store.selected[props.taxon.parentId]

    if (selectedItems) {
      const index = selectedItems.findIndex((t) => t.id === item.id)

      if (index > -1) {
        selectedItems.splice(index, 1)
      } else {
        selectedItems.push(item)
      }
    } else {
      store.selected[props.taxon.parentId] = [item]
    }
  }
}

const isSelected = computed(() =>
  store.selected[props.taxon.parentId]?.some(
    (item) => item.id === props.taxon.id
  )
)

function toggle() {
  if (!props.taxon.isLoaded) {
    expandNode(props.taxon.id)
  }

  props.taxon.isExpanded = !props.taxon.isExpanded
}

function makeTaxonNode(taxon) {
  return {
    id: taxon.id,
    name: taxon.label,
    parentId: taxon.parent_id,
    isValid: taxon.is_valid,
    leaf: taxon.leaf_node,
    synonyms: taxon.synonyms || [],
    children: []
  }
}

function expandNode(taxonId) {
  isLoading.value = true
  TaxonName.taxonomy(taxonId, {
    ancestors: false,
    count: false
  })
    .then(({ body }) => {
      const children = body.descendants.map((c) => makeTaxonNode(c))

      children.forEach((item, index) => {
        const current = props.taxon.children.find((c) => c.id === item.id)

        if (current) {
          children[index] = current
        }
      })

      props.taxon.isExpanded = true
      props.taxon.isLoaded = true
      props.taxon.children = children
    })
    .finally(() => {
      isLoading.value = false
    })
}

function handleChoose(e) {
  store.setCurrentDraggedTaxon({
    parent: props.taxon,
    taxon: props.taxon.children[e.oldIndex],
    index: e.oldIndex
  })
}

function reasignNode(parentId, index) {
  const targetParent = findNodeById(props.target, parentId)

  if (targetParent) {
    targetParent.children.splice(index, 0, {
      ...structuredClone(toRaw(store.currentDragged.taxon)),
      parentId: parentId
    })
  }
}

function handleAdd(e) {
  const { newIndex } = e
  const movedTaxon = props.taxon.children[newIndex]
  const payload = {
    taxon_name: { parent_id: props.taxon.id }
  }

  TaxonName.update(movedTaxon.id, payload)
    .then(({ body }) => {
      const newName = [body.cached_html, body.cached_author_year].join(' ')

      removeNode(props.tree, {
        id: movedTaxon.id,
        parentId: movedTaxon.parentId
      })

      Object.assign(movedTaxon, {
        parentId: body.parent_id,
        name: newName
      })

      reasignNode(movedTaxon.parentId, newIndex)

      TW.workbench.alert.create(`${newName} was reclassified to successfully`)
    })
    .catch(() => {
      props.taxon.children.splice(newIndex, 1)
      store.currentDragged.parent.children.splice(
        store.currentDragged.index,
        0,
        movedTaxon
      )
    })
}
</script>

<style scoped>
.list-reclassifer-taxon-item {
  border: 2px dashed transparent;
}

.list-reclassifer-taxon-item:hover,
.selected {
  border-color: var(--color-primary);
}

.sortable-ghost {
  .list-reclassifer-taxon-item:hover {
    border: 2px dashed transparent;
  }
  .list-reclassifer-taxon-item {
    border: 2px dashed var(--color-update);
  }
}

.ghost-list {
  .selected {
    border-color: var(--color-update);
  }
}
</style>
